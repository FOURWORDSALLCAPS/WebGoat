=== Смягчение обхода пути

Как мы видели в предыдущих заданиях, защита загрузки файла может быть сложной. Все сводится к доверию
вводу без его проверки.
В показанных ранее примерах решением может быть не доверять пользовательскому вводу и создание случайного имени файла на стороне
сервера.

Если вам нужно сохранить его на основе пользовательского ввода, лучший способ обезопасить себя — проверить канонический путь. Например, в Java:

[source]
----
var multiPartFile = ...
var targetFile = new File("/tmp", multiPartFile.getOriginalName());
var canonicalPath = targetFile.getCanonicalPath();

if (!canonicalPath.startWith("/tmp") {
  throw new IllegalArgumentException("Invalid filename");
}

IOUtils.copy(multiPartFile.getBytes(), targetFile);
----

Функция канонического пути преобразуется в абсолютный путь, удаляя `.` и `..` и т. д. Проверяя, находится ли канонический
путь внутри ожидаемого каталога.

Для обходов пути при извлечении можно применить тот же метод, описанный выше, но в качестве глубокой защиты вы также можете реализовать смягчение, запустив приложение под определенным непривилегированным пользователем, которому не разрешено читать и писать
в любом другом каталоге.

Убедитесь, что вы создаете обнаружение для перехвата этих случаев в любом случае, но будьте осторожны с возвратом явной информации
пользователю. Каждая крошечная деталь может дать злоумышленнику сведения о вашей системе.

==== Будьте осторожны...

Как показано в предыдущих примерах, будьте осторожны, какой метод вы используете для получения параметров, особенно параметров запроса.
Spring Boot неплохо справляется с запретом недопустимых переменных пути. Подведем итог:

[source]
----
@Getter("/f")
public void f(@RequestParam("name") String name) {
  //name is automatically decoded so %2E%2E%2F%2E%2E%2Ftest will become ../../test
}

@Getter("/g")
public void g(HttpServletRequest request) {
  var queryString = request.getQueryString(); // will return
}

@Getter("/h")
public void h(HttpServletRequest request) {
  var name = request.getParam("name"); //will return ../../test
----

Если вы вызовете `/f` с `/f?name=%2E%2E%2F%2E%2E%2Ftest`, то он станет `../../test`. Если вы вызовете `g` с
`/g?name=%2E%2E%2F%2E%2E%2Ftest`, то он вернет `%2E%2E%2F%2E%2E%2Ftest` *НЕТ* декодирования.
Поведение `/h` с тем же параметром будет таким же, как `/f`

Как видите, будьте осторожны и ознакомьтесь с правильными методами вызова. В каждом случае напишите
модульный тест в таких случаях, который охватывает закодированные символы.

==== Защита Spring Boot

По умолчанию Spring Boot имеет защиту для использования, например, `../` в пути. Проекция находится в классе `StrictHttpFirewall`. Это защитит конечную точку, где пользовательский ввод является частью `path`, например `/test/1.jpg`
если вы замените `1.jpg` на `../../secret.txt`, запрос будет заблокирован. С параметрами запроса эта защита
не будет.

В уроке о «Загрузках файлов» показаны дополнительные примеры уязвимостей.
