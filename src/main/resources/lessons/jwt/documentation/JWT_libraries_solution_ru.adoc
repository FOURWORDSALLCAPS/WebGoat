=== Решение

В прошлых заданиях мы научились **НЕ** доверять библиотекам делать для нас правильные вещи. В обоих случаях мы видели это даже при указании ключа JWT и передаче правильного алгоритма. Даже при использовании токена:

[source]
----
eyJhbGciOiJIUzI1NiJ9.ew0KICAiYWRtaW4iIDogdHJ1ZSwNCiAgImlhdCIgOiAxNTE2MjM5MDIyLA0KICAic3ViIiA6ICIxMjM0NTY3ODkwIiwNCiAgInVzZXIiIDogIkpvaG4gRG9lIg0KfQ.

{
  "alg" : "HS256"
},
{
  "admin" : true,
  "iat" : 1516239022,
  "sub" : "1234567890",
  "user" : "John Doe"
}
----

И следующий код Java:

[source]
----
Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);
----

Видите ли, мы устанавливаем ключ подписи с помощью `setSigningKey`, библиотека все равно пропускает проверку подписи.

Это не ограничивается только традиционной атакой `alg: none`, но также работает с `alg: HS256`.

=== Заключение

Когда вы выбрали библиотеку для работы с токенами JWT, убедитесь, что:

- используете правильный метод в своем коде при проверке токенов.
- добавляете тестовые случаи и проверяете алгоритм, путаница невозможна.
- как команда безопасности пишет служебные методы, которые будут использоваться командами, инкапсулирующими библиотеку, чтобы убедиться, что команды используют правильную логику анализа.

=== Альтернатива: Paseto

Путаница в алгоритме — это реальная проблема при работе с JWT, ее можно избежать, используя PASETO (**P**latform-**A**gnostic **SE**curity **TO**kens), который в настоящее время реализован в 10 языках программирования.

Одним из недостатков использования этого метода является то, что JWT широко распространен, например, подумайте об использовании OAuth, поэтому это может быть не лучшим решением для использования.

Для получения дополнительной информации посмотрите следующее видео:

video::RijGNytjbOI[youtube, height=480, width=100%]
