:linkattrs:

== Обновление токена

=== Введение

В этом разделе мы рассмотрим обновление токена доступа.

=== Типы токенов

В целом существует два типа токенов: токен доступа и токен обновления. Токен доступа используется для выполнения вызовов API
к серверу. Токены доступа имеют ограниченный срок действия, вот где вступает в дело токен обновления. Как только токен доступа становится недействительным, можно сделать запрос к серверу, чтобы получить новый токен доступа, предоставив токен обновления. Токен обновления может истечь, но его срок действия намного больше. Это решает проблему пользователя,
необходимого для повторной аутентификации с использованием своих учетных данных. Следует ли использовать токен обновления и токен доступа, зависит от того,
ниже приведено несколько моментов, которые следует учитывать при выборе используемых токенов.

Итак, обычный поток может выглядеть так:

```
curl -X POST -H -d 'username=webgoat&password=webgoat' localhost:8080/WebGoat/login
```

Сервер возвращает:

```
{
    "token_type":"bearer",
    "access_token":"XXXX.YYYY.ZZZZ",
    "expires_in":10,
    "refresh_token":"4a9a0b1eac1a34201b3c5659944e8b7"
}
```

Как вы видите, токен обновления — это случайная строка, которую сервер может отслеживать (в памяти или хранить в базе данных),
чтобы сопоставить токен обновления с пользователем, которому был предоставлен токен обновления.
Таким образом, в этом случае, когда токен доступа все еще действителен, мы можем говорить о сеансе «без состояния»,
нет нагрузки на стороне сервера по настройке сеанса пользователя, токен является самодостаточным.
Когда токен доступа больше не действителен, серверу необходимо запросить сохраненный токен обновления, чтобы убедиться, что токен
никам не заблокирован.

Всякий раз, когда злоумышленник получает токен доступа, он действителен только в течение определенного периода времени (например, 10 минут). Затем злоумышленнику нужен токен обновления, чтобы получить новый токен доступа. Вот почему токен обновления нуждается в лучшей защите.
Также можно сделать токен обновления без состояния, но это означает, что будет сложнее определить,
отозвал ли пользователь токены.
После того, как сервер выполнит все проверки, он должен вернуть клиенту новый токен обновления и новый токен доступа. Клиент может использовать новый токен доступа для вызова API.

=== Что следует проверить?

Независимо от выбранного решения, вы должны хранить достаточно информации на стороне сервера, чтобы проверить, является ли пользователь
доверенным. Вы можете придумать много вещей, например, сохранить IP-адрес, отслеживать, сколько раз используется токен обновления (использование токена обновления несколько раз в допустимом временном окне токена доступа может указывать на странное поведение, вы можете отозвать все токены и позволить пользователю пройти аутентификацию снова). Также отслеживайте, какой токен доступа принадлежал какому токену обновления, иначе злоумышленник может
смогу получить новый токен доступа для другого пользователя с токеном обновления злоумышленника
(см. https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/ для хорошего описания того, как работает эта атака)
Также полезно проверить IP-адрес или геолокацию пользователя. Если вам нужно выдать новый токен, проверьте,
осталось ли местоположение прежним, если нет, отзовите все токены и дайте пользователю снова пройти аутентификацию.

=== Необходимость токенов обновления

Имеет ли смысл использовать токен обновления в современном одностраничном приложении (SPA)? Как мы видели в разделе о хранении токенов, есть два варианта: веб-хранилище или файл cookie, что означает, что токен обновления находится прямо рядом с токеном доступа, поэтому, если токен доступа утечет, скорее всего, токен обновления также будет скомпрометирован. В большинстве случаев, конечно, есть разница. Токен доступа отправляется, когда вы делаете вызов API, токен обновления отправляется только
когда должен быть получен новый токен доступа, что в большинстве случаев является другой конечной точкой. Если вы оказываетесь на том же
сервере, вы можете выбрать использование только токена доступа.

Как указано выше, использование токена доступа и отдельного токена обновления дает серверу некоторое преимущество, чтобы не проверять токен доступа снова и снова. Выполняйте проверку только тогда, когда пользователю нужен новый токен доступа.

Конечно, можно использовать только токен доступа. На сервере вы храните точно такую же информацию, которую
хранили бы для токена обновления, см. предыдущий абзац. Таким образом, вам нужно проверять токен каждый раз, но это может быть
подходящим в зависимости от приложения. В случае, если токены обновления хранятся для проверки, важно также защитить эти токены (по крайней мере
использовать хэш-функцию для их хранения в вашей базе данных).

=== JWT хорошая идея?

Существует множество доступных ресурсов, которые подвергают сомнению вариант использования токена JWT для аутентификации клиента на сервере
в отношении файлов cookie. Лучшее место для использования токена JWT — это связь между сервером и сервером. В обычном веб-
приложении вам лучше использовать обычные старые файлы cookie. Для получения дополнительной информации см.:

- http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/[прекратить использование jwt для сеансов, window="_blank"]
- http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/[прекратить-использование-jwt-для-сессий-часть-2-почему-ваше-решение-не-работает, window="_blank"]
- http://cryto.net/~joepie91/blog/attachments/jwt-flowchart.png[блок-схема, window="_blank"]
